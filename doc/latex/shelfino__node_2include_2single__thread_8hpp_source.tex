\hypertarget{shelfino__node_2include_2single__thread_8hpp_source}{}\doxysection{single\+\_\+thread.\+hpp}
\label{shelfino__node_2include_2single__thread_8hpp_source}\index{X:/shelfino\_node/include/single\_thread.hpp@{X:/shelfino\_node/include/single\_thread.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * single\_thread.h}}
\DoxyCodeLine{3 \textcolor{comment}{ *}}
\DoxyCodeLine{4 \textcolor{comment}{ *  Created on: July 6, 2015}}
\DoxyCodeLine{5 \textcolor{comment}{ *      Author: "{}Alessio Colombo <alessio.col@gmail.com>"{}}}
\DoxyCodeLine{6 \textcolor{comment}{        Reviewed by "{}Fabiano Zenatti <fabiano.zenatti@gmail.com>"{}"{}}}
\DoxyCodeLine{7 \textcolor{comment}{ */}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#ifndef SINGLE\_THREAD\_H\_}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#define SINGLE\_THREAD\_H\_}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <condition\_variable>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <thread>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <system\_error>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{keyword}{namespace }Common \{}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{class }single\_thread \{}
\DoxyCodeLine{23   \textcolor{keyword}{public}:}
\DoxyCodeLine{24 }
\DoxyCodeLine{25     \textcolor{keyword}{typedef} std::function<void(\textcolor{keyword}{const} \textcolor{keywordtype}{bool}\&)> thread\_fun\_t;}
\DoxyCodeLine{26     \textcolor{keyword}{typedef} std::function<void()> terminating\_fun\_t;}
\DoxyCodeLine{27 }
\DoxyCodeLine{28     single\_thread(\textcolor{keyword}{const} std::string\& thread\_name = \textcolor{stringliteral}{"{}single\_thread"{}}) :}
\DoxyCodeLine{29         alive(false), terminating(false), joined(true),}
\DoxyCodeLine{30         exception\_thrown(false), default\_tout\_ms(60000),}
\DoxyCodeLine{31         thread\_name(thread\_name) \{}
\DoxyCodeLine{32       custom\_worker = [](\textcolor{keyword}{const} \textcolor{keywordtype}{bool}\&)\{\};}
\DoxyCodeLine{33       custom\_terminating\_callback = []()\{\};}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37     single\_thread(thread\_fun\_t f, \textcolor{keyword}{const} std::string\& thread\_name) :}
\DoxyCodeLine{38         alive(false), terminating(false), joined(true),}
\DoxyCodeLine{39         exception\_thrown(false), default\_tout\_ms(60000),}
\DoxyCodeLine{40         thread\_name(thread\_name), custom\_worker(f) \{}
\DoxyCodeLine{41           custom\_terminating\_callback = []()\{\};}
\DoxyCodeLine{42     \}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44     single\_thread(thread\_fun\_t f, terminating\_fun\_t ft, \textcolor{keyword}{const} std::string\& thread\_name) :}
\DoxyCodeLine{45         alive(false), terminating(false), joined(true),}
\DoxyCodeLine{46         exception\_thrown(false), default\_tout\_ms(60000),}
\DoxyCodeLine{47         thread\_name(thread\_name), custom\_worker(f) \{}
\DoxyCodeLine{48           custom\_terminating\_callback = ft;}
\DoxyCodeLine{49     \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} start() \{}
\DoxyCodeLine{52       std::lock\_guard<std::mutex> lock(mutex\_run);}
\DoxyCodeLine{53       \textcolor{keywordflow}{if} (alive) \{}
\DoxyCodeLine{54         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{55       \}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57       join\_if\_needed();}
\DoxyCodeLine{58 }
\DoxyCodeLine{59       exception\_thrown = \textcolor{keyword}{false};}
\DoxyCodeLine{60       terminating = \textcolor{keyword}{false};}
\DoxyCodeLine{61       innerThread.reset(\textcolor{keyword}{new} std::thread(\&single\_thread::worker, \textcolor{keyword}{this}));}
\DoxyCodeLine{62 }
\DoxyCodeLine{63       \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{64         std::unique\_lock<std::mutex> lock\_wk(mutex\_worker);}
\DoxyCodeLine{65         \textcolor{keywordflow}{if} (cond\_worker\_start.wait\_for(lock\_wk, std::chrono::milliseconds(default\_tout\_ms), [\textcolor{keyword}{this}]()\{return this-\/>alive;\})) \{}
\DoxyCodeLine{66           \textcolor{comment}{//std::cout << thread\_name << "{}::start(), thread started successfully."{} << std::endl;}}
\DoxyCodeLine{67           \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{68         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{69           std::cerr << thread\_name << \textcolor{stringliteral}{"{}::start(), thread not started after timeout ("{}} << default\_tout\_ms << \textcolor{stringliteral}{"{} ms)"{}} << std::endl;}
\DoxyCodeLine{70           \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{71         \}}
\DoxyCodeLine{72       \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception\& e) \{}
\DoxyCodeLine{73         std::cerr << thread\_name << \textcolor{stringliteral}{"{}::start(), exception generated: \(\backslash\)"{}"{}}<< e.what() << \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}} << std::endl;}
\DoxyCodeLine{74         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{75       \}}
\DoxyCodeLine{76     \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} stop() \{}
\DoxyCodeLine{79       std::lock\_guard<std::mutex> lock(mutex\_run);}
\DoxyCodeLine{80       \textcolor{keywordflow}{if} (!alive \&\& joined) \{}
\DoxyCodeLine{81         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{82       \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84       \textcolor{keywordflow}{if} (join\_if\_needed()) \{}
\DoxyCodeLine{85         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{86       \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88       mutex\_stop\_req.lock(); }
\DoxyCodeLine{89       terminating = \textcolor{keyword}{true};}
\DoxyCodeLine{90       mutex\_stop\_req.unlock(); }
\DoxyCodeLine{91       cond\_worker\_stop\_req.notify\_all();}
\DoxyCodeLine{92       \textcolor{keywordtype}{bool} has\_error = \textcolor{keyword}{false};}
\DoxyCodeLine{93       \textcolor{comment}{//std::cout << thread\_name << "{}::stop(), stopping thread ("{} << default\_tout\_ms << "{} ms timeout)"{} << std::endl;}}
\DoxyCodeLine{94       \textcolor{comment}{//std::cout.flush();}}
\DoxyCodeLine{95       \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{96         std::unique\_lock<std::mutex> lock\_wk(mutex\_worker);}
\DoxyCodeLine{97         \textcolor{keywordflow}{if} (cond\_worker\_stop.wait\_for(lock\_wk, std::chrono::milliseconds(default\_tout\_ms), [\textcolor{keyword}{this}]()\{return !this-\/>alive;\})) \{}
\DoxyCodeLine{98           \textcolor{comment}{//std::cout << thread\_name << "{}::stop(), thread stopped successfully."{} << std::endl;}}
\DoxyCodeLine{99         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{100           std::cerr << thread\_name << \textcolor{stringliteral}{"{}::stop(), thread not stopped after timeout"{}} << std::endl;}
\DoxyCodeLine{101           has\_error = \textcolor{keyword}{true};}
\DoxyCodeLine{102         \}}
\DoxyCodeLine{103       \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception\& e) \{}
\DoxyCodeLine{104         std::cerr << thread\_name << \textcolor{stringliteral}{"{}::stop(), exception generated: \(\backslash\)"{}"{}}<< e.what() << \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}} << std::endl;}
\DoxyCodeLine{105         has\_error = \textcolor{keyword}{true};}
\DoxyCodeLine{106       \}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108       \textcolor{keywordflow}{if} (!has\_error \&\& innerThread) \{}
\DoxyCodeLine{109         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{110           innerThread-\/>join();}
\DoxyCodeLine{111         \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::system\_error\& syserr) \{}
\DoxyCodeLine{112           std::cerr << thread\_name << \textcolor{stringliteral}{"{}::stop(), exception generated while joining thread: \(\backslash\)"{}"{}}<< syserr.what() << \textcolor{stringliteral}{"{}\(\backslash\)"{}."{}}}
\DoxyCodeLine{113            << std::endl << \textcolor{stringliteral}{"{}No panic! We are strong enough to continue anyway.."{}}<< std::endl;}
\DoxyCodeLine{114         \}}
\DoxyCodeLine{115       \}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117       std::cout.flush();}
\DoxyCodeLine{118       std::cerr.flush();}
\DoxyCodeLine{119       \textcolor{keywordflow}{return} !has\_error;}
\DoxyCodeLine{120     \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122     \textcolor{keywordtype}{void} notifyTermination() \{}
\DoxyCodeLine{123       terminating = \textcolor{keyword}{true};}
\DoxyCodeLine{124     \}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126     \textcolor{keywordtype}{bool} isAlive()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{127       \textcolor{keywordflow}{return} alive;}
\DoxyCodeLine{128     \}}
\DoxyCodeLine{129     \textcolor{keywordtype}{bool} isTerminating()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{130       \textcolor{keywordflow}{return} terminating;}
\DoxyCodeLine{131     \}}
\DoxyCodeLine{132     \textcolor{keywordtype}{bool} isExceptionThrown()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{133       \textcolor{keywordflow}{return} exception\_thrown;}
\DoxyCodeLine{134     \}}
\DoxyCodeLine{135     uint32\_t getDefaultTimeoutMilli()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{136       \textcolor{keywordflow}{return} default\_tout\_ms;}
\DoxyCodeLine{137     \}}
\DoxyCodeLine{138     \textcolor{keywordtype}{void} setDefaultTimeoutMilli(uint32\_t tout\_ms) \{}
\DoxyCodeLine{139       default\_tout\_ms = tout\_ms;}
\DoxyCodeLine{140     \}}
\DoxyCodeLine{141 }
\DoxyCodeLine{142     \textcolor{keywordtype}{void} setThreadFunction(thread\_fun\_t tf) \{custom\_worker = tf;\}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144     \textcolor{keyword}{const} std::exception\& getLastException()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} last\_exception;\}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146     std::string getThreadName()\{ \textcolor{keywordflow}{return} thread\_name; \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \textcolor{keyword}{virtual} \string~single\_thread() \{stop();\}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150   \textcolor{keyword}{protected}:}
\DoxyCodeLine{151 }
\DoxyCodeLine{152     \textcolor{comment}{// function to be called from within the custom\_worker() function and}}
\DoxyCodeLine{153     \textcolor{comment}{// will block until stop() is called.}}
\DoxyCodeLine{154     \textcolor{comment}{// this has been done in order to avoid the ugly}}
\DoxyCodeLine{155     \textcolor{comment}{//}}
\DoxyCodeLine{156     \textcolor{comment}{// while(!terminating) \{sleep(some time);\}}}
\DoxyCodeLine{157     \textcolor{comment}{//}}
\DoxyCodeLine{158     \textcolor{keywordtype}{bool} workerSelfWaitForTerminationRequest() \{}
\DoxyCodeLine{159       \textcolor{keywordflow}{if} (!alive) \{}
\DoxyCodeLine{160         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{161       \}}
\DoxyCodeLine{162 }
\DoxyCodeLine{163       \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{164         std::unique\_lock<std::mutex> lock\_wk(mutex\_stop\_req);}
\DoxyCodeLine{165         cond\_worker\_stop\_req.wait(lock\_wk, [\textcolor{keyword}{this}]\{\textcolor{keywordflow}{return} terminating;\});}
\DoxyCodeLine{166       \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception\& e) \{}
\DoxyCodeLine{167         std::cerr << thread\_name << \textcolor{stringliteral}{"{}::waitForTerminationRequest(), exception "{}} << e.what() << std::endl;}
\DoxyCodeLine{168         std::cerr.flush();}
\DoxyCodeLine{169         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{170       \}}
\DoxyCodeLine{171       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{172     \}}
\DoxyCodeLine{173 }
\DoxyCodeLine{174   \textcolor{keyword}{private}:}
\DoxyCodeLine{175 }
\DoxyCodeLine{176     std::condition\_variable cond\_worker\_start, cond\_worker\_stop, cond\_worker\_stop\_req;}
\DoxyCodeLine{177     std::mutex mutex\_run, mutex\_worker, mutex\_stop\_req;}
\DoxyCodeLine{178     \textcolor{keywordtype}{bool} alive, terminating, joined;}
\DoxyCodeLine{179     std::unique\_ptr<std::thread> innerThread;}
\DoxyCodeLine{180     \textcolor{keywordtype}{bool} exception\_thrown;}
\DoxyCodeLine{181     std::exception last\_exception;}
\DoxyCodeLine{182     uint32\_t default\_tout\_ms;}
\DoxyCodeLine{183     std::string thread\_name;}
\DoxyCodeLine{184     thread\_fun\_t custom\_worker;}
\DoxyCodeLine{185     terminating\_fun\_t custom\_terminating\_callback;}
\DoxyCodeLine{186 }
\DoxyCodeLine{187     \textcolor{keywordtype}{bool} join\_if\_needed() \{}
\DoxyCodeLine{188       \textcolor{keywordflow}{if} (!alive \&\& !joined) \{}
\DoxyCodeLine{189         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{190           \textcolor{keywordflow}{if} (innerThread-\/>joinable()) \{}
\DoxyCodeLine{191             innerThread-\/>join();}
\DoxyCodeLine{192           \}}
\DoxyCodeLine{193         \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::system\_error\& syserr) \{}
\DoxyCodeLine{194           std::cerr << thread\_name << \textcolor{stringliteral}{"{}::stop(), exception generated while joining thread: \(\backslash\)"{}"{}}<< syserr.what() << \textcolor{stringliteral}{"{}\(\backslash\)"{}."{}}}
\DoxyCodeLine{195            << std::endl << \textcolor{stringliteral}{"{}No panic! We are strong enough to continue anyway.."{}}<< std::endl;}
\DoxyCodeLine{196         \}}
\DoxyCodeLine{197         joined = \textcolor{keyword}{true};}
\DoxyCodeLine{198         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{199       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{200         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{201       \}}
\DoxyCodeLine{202     \}}
\DoxyCodeLine{203 }
\DoxyCodeLine{204     \textcolor{keywordtype}{void} worker() \{}
\DoxyCodeLine{205       alive = \textcolor{keyword}{true};}
\DoxyCodeLine{206       joined = \textcolor{keyword}{false};}
\DoxyCodeLine{207       cond\_worker\_start.notify\_all();}
\DoxyCodeLine{208       \textcolor{comment}{//std::cout << thread\_name << "{} hello!"{} << std::endl;}}
\DoxyCodeLine{209       \textcolor{comment}{//std::cout.flush();}}
\DoxyCodeLine{210       \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{211         custom\_worker(terminating);}
\DoxyCodeLine{212       \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception\& e) \{}
\DoxyCodeLine{213         exception\_thrown = \textcolor{keyword}{true};}
\DoxyCodeLine{214         last\_exception = e;}
\DoxyCodeLine{215         std::cout << thread\_name << \textcolor{stringliteral}{"{}::worker(), exception generated: \(\backslash\)"{}"{}}<< e.what() << \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}} << std::endl;}
\DoxyCodeLine{216         std::cout.flush();}
\DoxyCodeLine{217       \}}
\DoxyCodeLine{218       terminating = \textcolor{keyword}{true};}
\DoxyCodeLine{219       \textcolor{comment}{//std::cout << thread\_name << "{} goodbye :("{} << std::endl;}}
\DoxyCodeLine{220       \textcolor{comment}{//std::cout.flush();}}
\DoxyCodeLine{221       alive = \textcolor{keyword}{false};}
\DoxyCodeLine{222       cond\_worker\_stop.notify\_all();}
\DoxyCodeLine{223       custom\_terminating\_callback();}
\DoxyCodeLine{224     \}}
\DoxyCodeLine{225 \};}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 \}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ALGORITHM\_H\_ */}\textcolor{preprocessor}{}}

\end{DoxyCode}
