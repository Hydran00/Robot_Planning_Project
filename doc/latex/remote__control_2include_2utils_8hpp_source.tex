\hypertarget{remote__control_2include_2utils_8hpp_source}{}\doxysection{utils.\+hpp}
\label{remote__control_2include_2utils_8hpp_source}\index{X:/remote\_control/include/utils.hpp@{X:/remote\_control/include/utils.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4 \textcolor{comment}{// \#include <opencv2/opencv.hpp>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}robotstatus.h"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}json.hpp"{}}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} real\_type;}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} CAM\_WIDTH\_SMALL  = 800;}
\DoxyCodeLine{15 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} CAM\_HEIGHT\_SMALL = CAM\_WIDTH\_SMALL*9/16;}
\DoxyCodeLine{16 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} CAM\_FPS\_SMALL    = 30;}
\DoxyCodeLine{17 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} ROBOT\_CONNECTED = \textcolor{keyword}{true};}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_point2d}{Point2d}} \{}
\DoxyCodeLine{21   \mbox{\hyperlink{struct_point2d}{Point2d}}() \{\}}
\DoxyCodeLine{22   \mbox{\hyperlink{struct_point2d}{Point2d}}(real\_type x, real\_type y): x(x), y(y) \{\}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\mbox{\hyperlink{struct_point2d}{Point2d}} \textcolor{keyword}{const} \& p1, \mbox{\hyperlink{struct_point2d}{Point2d}} \textcolor{keyword}{const} \& p2) \{ \textcolor{keywordflow}{return} p1.x==p2.x \&\& p1.y==p2.y; \}}
\DoxyCodeLine{25   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\mbox{\hyperlink{struct_point2d}{Point2d}} \textcolor{keyword}{const} \& p1, \mbox{\hyperlink{struct_point2d}{Point2d}} \textcolor{keyword}{const} \& p2) \{ \textcolor{keywordflow}{return} !(p1==p2); \}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27   real\_type x, y;}
\DoxyCodeLine{28 \};}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_pose}{Pose}} \{}
\DoxyCodeLine{31   real\_type x, y, theta;}
\DoxyCodeLine{32 \};}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 \textcolor{keyword}{typedef} \mbox{\hyperlink{struct_pose}{Pose}} \mbox{\hyperlink{struct_pose}{State2d}};}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{keyword}{typedef} std::vector<Point2d> Obstacle;}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_scan_data}{ScanData}}}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40   std::vector<RobotStatus::LidarData> data;}
\DoxyCodeLine{41   \mbox{\hyperlink{struct_pose}{Pose}} pose;}
\DoxyCodeLine{42 \};}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_wayline}{Wayline}} \{}
\DoxyCodeLine{46   real\_type xc, yc;}
\DoxyCodeLine{47   real\_type theta;}
\DoxyCodeLine{48   real\_type L;}
\DoxyCodeLine{49   \textcolor{keywordtype}{size\_t} npts;}
\DoxyCodeLine{50 }
\DoxyCodeLine{51   \textcolor{comment}{//vector<real\_type> \_x, \_y;}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{comment}{//public:}}
\DoxyCodeLine{54   \mbox{\hyperlink{struct_wayline}{Wayline}}(real\_type xc, }
\DoxyCodeLine{55           real\_type yc,}
\DoxyCodeLine{56           real\_type theta,}
\DoxyCodeLine{57           real\_type L,}
\DoxyCodeLine{58           \textcolor{keywordtype}{int} npts):}
\DoxyCodeLine{59     xc(xc), yc(yc), theta(theta), L(L), npts(npts)        }
\DoxyCodeLine{60   \{\}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{63     \textcolor{keywordflow}{return} 2*npts + 1;}
\DoxyCodeLine{64   \}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66   }
\DoxyCodeLine{67   real\_type x(\textcolor{keywordtype}{int} idx)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{68     \textcolor{keywordflow}{if} (!npts) \textcolor{keywordflow}{return} xc;}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     real\_type ds = L/npts;}
\DoxyCodeLine{71     real\_type cos\_theta = cos(theta);}
\DoxyCodeLine{72     real\_type sin\_theta = sin(theta);}
\DoxyCodeLine{73     }
\DoxyCodeLine{74     \textcolor{comment}{// 0 -\/>  0}}
\DoxyCodeLine{75     \textcolor{comment}{// 1 -\/>  1, 2 -\/> -\/1}}
\DoxyCodeLine{76     \textcolor{comment}{// 3 -\/>  2, 4 -\/> -\/2}}
\DoxyCodeLine{77     \textcolor{comment}{// 5 -\/>  3, 6 -\/> -\/3}}
\DoxyCodeLine{78     \textcolor{keywordtype}{int} sign = idx\%2==0 ? -\/1 : +1;}
\DoxyCodeLine{79     idx = (idx+1)/2;}
\DoxyCodeLine{80     real\_type cl = sign*idx*ds;}
\DoxyCodeLine{81     \textcolor{keywordflow}{return} xc+cl*cos\_theta;}
\DoxyCodeLine{82   \} }
\DoxyCodeLine{83   }
\DoxyCodeLine{84   real\_type y(\textcolor{keywordtype}{int} idx)\textcolor{keyword}{ const }\{ }
\DoxyCodeLine{85     \textcolor{keywordflow}{if} (!npts) \textcolor{keywordflow}{return} yc;}
\DoxyCodeLine{86 }
\DoxyCodeLine{87     real\_type ds = L/npts;}
\DoxyCodeLine{88     real\_type cos\_theta = cos(theta);}
\DoxyCodeLine{89     real\_type sin\_theta = sin(theta);}
\DoxyCodeLine{90     }
\DoxyCodeLine{91     \textcolor{comment}{// 0 -\/>  0}}
\DoxyCodeLine{92     \textcolor{comment}{// 1 -\/>  1, 2 -\/> -\/1}}
\DoxyCodeLine{93     \textcolor{comment}{// 3 -\/>  2, 4 -\/> -\/2}}
\DoxyCodeLine{94     \textcolor{comment}{// 5 -\/>  3, 6 -\/> -\/3}}
\DoxyCodeLine{95     \textcolor{keywordtype}{int} sign = idx\%2==0 ? -\/1 : +1;}
\DoxyCodeLine{96     idx = (idx+1)/2;}
\DoxyCodeLine{97     real\_type cl = sign*idx*ds;}
\DoxyCodeLine{98     \textcolor{keywordflow}{return} yc+cl*sin\_theta;}
\DoxyCodeLine{99   \} }
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \};}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_angular_range}{AngularRange}} \{}
\DoxyCodeLine{104   real\_type thetac;}
\DoxyCodeLine{105   real\_type L;}
\DoxyCodeLine{106   \textcolor{keywordtype}{size\_t} npts;}
\DoxyCodeLine{107   std::vector<real\_type> special;}
\DoxyCodeLine{108 }
\DoxyCodeLine{109   \textcolor{comment}{//vector<real\_type> \_x, \_y;}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{comment}{//public:}}
\DoxyCodeLine{112   \mbox{\hyperlink{struct_angular_range}{AngularRange}}(real\_type thetac, }
\DoxyCodeLine{113                real\_type L,}
\DoxyCodeLine{114                \textcolor{keywordtype}{int} npts):}
\DoxyCodeLine{115     thetac(thetac), L(L), npts(npts)        }
\DoxyCodeLine{116   \{\}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{119     \textcolor{keywordflow}{return} 2*npts + 1 + special.size();}
\DoxyCodeLine{120   \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122   real\_type theta(\textcolor{keywordtype}{int} idx)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{123     \textcolor{keywordflow}{if} (!idx) \textcolor{keywordflow}{return} thetac;}
\DoxyCodeLine{124     \textcolor{keywordflow}{if} (idx>2*npts) \{}
\DoxyCodeLine{125       \textcolor{keywordflow}{return} special[idx-\/2*npts-\/1];}
\DoxyCodeLine{126     \}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128     real\_type ds = L/npts;}
\DoxyCodeLine{129        }
\DoxyCodeLine{130     \textcolor{comment}{// 0 -\/>  0}}
\DoxyCodeLine{131     \textcolor{comment}{// 1 -\/>  1, 2 -\/> -\/1}}
\DoxyCodeLine{132     \textcolor{comment}{// 3 -\/>  2, 4 -\/> -\/2}}
\DoxyCodeLine{133     \textcolor{comment}{// 5 -\/>  3, 6 -\/> -\/3}}
\DoxyCodeLine{134     \textcolor{keywordtype}{int} sign = idx\%2==0 ? -\/1 : +1;}
\DoxyCodeLine{135     idx = (idx+1)/2;}
\DoxyCodeLine{136     real\_type cl = sign*idx*ds;}
\DoxyCodeLine{137     \textcolor{keywordflow}{return} thetac+cl;}
\DoxyCodeLine{138   \} }
\DoxyCodeLine{139 }
\DoxyCodeLine{140   \textcolor{keywordtype}{void} addSpecial(real\_type theta) \{}
\DoxyCodeLine{141     special.push\_back(theta);}
\DoxyCodeLine{142   \}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \};}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{comment}{// struct Map}}
\DoxyCodeLine{147 \textcolor{comment}{// \{}}
\DoxyCodeLine{148 \textcolor{comment}{//   double resolution;}}
\DoxyCodeLine{149 \textcolor{comment}{//   double x0;}}
\DoxyCodeLine{150 \textcolor{comment}{//   double y0;}}
\DoxyCodeLine{151 \textcolor{comment}{//   cv::Mat img;}}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{comment}{//   void map2world(int i, int j, double \& x, double \& y) const}}
\DoxyCodeLine{154 \textcolor{comment}{//   \{}}
\DoxyCodeLine{155 \textcolor{comment}{// //    x = (j+0.5)*resolution + x0;}}
\DoxyCodeLine{156 \textcolor{comment}{// //    y = (i+0.5)*resolution + y0;}}
\DoxyCodeLine{157 \textcolor{comment}{//     x = (j)*resolution + x0;}}
\DoxyCodeLine{158 \textcolor{comment}{//     y = (i)*resolution + y0;}}
\DoxyCodeLine{159 \textcolor{comment}{//   \}}}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{comment}{//   void world2map(double x, double y, int \& i, int \& j) const}}
\DoxyCodeLine{162 \textcolor{comment}{//   \{}}
\DoxyCodeLine{163 \textcolor{comment}{// //    i = (y-\/y0)/resolution+0.5;}}
\DoxyCodeLine{164 \textcolor{comment}{// //    j = (x-\/x0)/resolution+0.5;}}
\DoxyCodeLine{165 \textcolor{comment}{//     i = std::round((y-\/y0)/resolution);}}
\DoxyCodeLine{166 \textcolor{comment}{//     j = std::round((x-\/x0)/resolution);}}
\DoxyCodeLine{167 \textcolor{comment}{//   \}}}
\DoxyCodeLine{168 \textcolor{comment}{// \};}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 \textcolor{keyword}{inline}}
\DoxyCodeLine{171 \textcolor{keywordtype}{int} Signum(\textcolor{keywordtype}{double} x)\{}
\DoxyCodeLine{172   \textcolor{keywordflow}{if}(x>0)\{}
\DoxyCodeLine{173     \textcolor{keywordflow}{return} 1.0;}
\DoxyCodeLine{174   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(x<0)\{}
\DoxyCodeLine{175     \textcolor{keywordflow}{return} -\/1.0;}
\DoxyCodeLine{176   \}\textcolor{keywordflow}{else}\{}
\DoxyCodeLine{177     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{178   \}}
\DoxyCodeLine{179 \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{keyword}{inline}}
\DoxyCodeLine{182 \textcolor{keywordtype}{bool} getObstacles(\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann::json}} \textcolor{keyword}{const} \& jdata, std::vector<Obstacle>\& obstacles)}
\DoxyCodeLine{183 \{}
\DoxyCodeLine{184   \textcolor{keyword}{using }\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann::json}};}
\DoxyCodeLine{185 }
\DoxyCodeLine{186   obstacles.\mbox{\hyperlink{classnlohmann_1_1basic__json_abfeba47810ca72f2176419942c4e1952}{clear}}();}
\DoxyCodeLine{187 }
\DoxyCodeLine{188   \textcolor{keywordtype}{double} x, y;}
\DoxyCodeLine{189     }
\DoxyCodeLine{190   \textcolor{keywordflow}{try} }
\DoxyCodeLine{191   \{}
\DoxyCodeLine{192     \mbox{\hyperlink{namespacenlohmann_a9cc9a3033850a092f791d86854d117fc}{json}} j\_arr\_boundaries = jdata.\mbox{\hyperlink{classnlohmann_1_1basic__json_a73ae333487310e3302135189ce8ff5d8}{at}}(\textcolor{stringliteral}{"{}boundaries"{}});}
\DoxyCodeLine{193     \mbox{\hyperlink{namespacenlohmann_a9cc9a3033850a092f791d86854d117fc}{json}} j\_arr\_obstacles  = jdata.\mbox{\hyperlink{classnlohmann_1_1basic__json_a73ae333487310e3302135189ce8ff5d8}{at}}(\textcolor{stringliteral}{"{}obstacles"{}});}
\DoxyCodeLine{194   }
\DoxyCodeLine{195     Obstacle curr;}
\DoxyCodeLine{196     \textcolor{keywordflow}{for} (json::iterator it = j\_arr\_boundaries.begin(); it != j\_arr\_boundaries.end(); ++it) }
\DoxyCodeLine{197     \{      }
\DoxyCodeLine{198       x = (*it).\mbox{\hyperlink{classnlohmann_1_1basic__json_a73ae333487310e3302135189ce8ff5d8}{at}}(\textcolor{stringliteral}{"{}x"{}});}
\DoxyCodeLine{199       y = (*it).\mbox{\hyperlink{classnlohmann_1_1basic__json_a73ae333487310e3302135189ce8ff5d8}{at}}(\textcolor{stringliteral}{"{}y"{}}); }
\DoxyCodeLine{200       curr.\mbox{\hyperlink{classnlohmann_1_1basic__json_ac8e523ddc8c2dd7e5d2daf0d49a9c0d7}{push\_back}}(\{x, y\});}
\DoxyCodeLine{201     \}}
\DoxyCodeLine{202     \textcolor{keywordflow}{if} (curr.back() != curr.front())}
\DoxyCodeLine{203       curr.push\_back(curr.front());}
\DoxyCodeLine{204     obstacles.push\_back(curr);}
\DoxyCodeLine{205 }
\DoxyCodeLine{206     \textcolor{keywordflow}{for} (json::iterator it = j\_arr\_obstacles.begin(); it != j\_arr\_obstacles.end(); ++it) }
\DoxyCodeLine{207     \{}
\DoxyCodeLine{208       Obstacle curr;     }
\DoxyCodeLine{209 }
\DoxyCodeLine{210       \mbox{\hyperlink{namespacenlohmann_a9cc9a3033850a092f791d86854d117fc}{json}} tmp\_obstacles = (*it).at(\textcolor{stringliteral}{"{}data"{}});}
\DoxyCodeLine{211       \textcolor{keywordflow}{for} (json::iterator itt = tmp\_obstacles.begin(); itt != tmp\_obstacles.end(); ++itt) }
\DoxyCodeLine{212       \{}
\DoxyCodeLine{213         curr.push\_back(\{(*itt).at(\textcolor{stringliteral}{"{}x"{}}), (*itt).at(\textcolor{stringliteral}{"{}y"{}})\});}
\DoxyCodeLine{214       \}}
\DoxyCodeLine{215       \textcolor{keywordflow}{if} (curr.back() != curr.front())}
\DoxyCodeLine{216         curr.push\_back(curr.front());}
\DoxyCodeLine{217       obstacles.push\_back(curr);}
\DoxyCodeLine{218     \}}
\DoxyCodeLine{219   \} }
\DoxyCodeLine{220   \textcolor{keywordflow}{catch} (std::exception \& ex)}
\DoxyCodeLine{221   \{}
\DoxyCodeLine{222     std::cerr << ex.what() << std::endl;}
\DoxyCodeLine{223     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{224   \}}
\DoxyCodeLine{225 }
\DoxyCodeLine{226   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{227 \}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{keyword}{inline}}
\DoxyCodeLine{230 \textcolor{keywordtype}{bool} getObstacles(std::string \textcolor{keyword}{const} \& filename, std::vector<Obstacle> \& map) }
\DoxyCodeLine{231 \{}
\DoxyCodeLine{232   map.clear();}
\DoxyCodeLine{233 }
\DoxyCodeLine{234   std::ifstream input(filename);}
\DoxyCodeLine{235   \textcolor{keywordflow}{if} (!input.is\_open())}
\DoxyCodeLine{236   \{}
\DoxyCodeLine{237     std::cerr << \textcolor{stringliteral}{"{}Error opening file "{}} << filename << std::endl;}
\DoxyCodeLine{238     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{239   \}}
\DoxyCodeLine{240 }
\DoxyCodeLine{241   \textcolor{keywordflow}{try} }
\DoxyCodeLine{242   \{}
\DoxyCodeLine{243     std::string str((std::istreambuf\_iterator<char>(input)), std::istreambuf\_iterator<char>());}
\DoxyCodeLine{244     \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann::json}} jdata = \mbox{\hyperlink{classnlohmann_1_1basic__json_a86f339e8449cce96b89e86635a7d389e}{nlohmann::json::parse}}(str);}
\DoxyCodeLine{245     \textcolor{keywordflow}{return} getObstacles(jdata, map);}
\DoxyCodeLine{246   \} }
\DoxyCodeLine{247   \textcolor{keywordflow}{catch} (...)}
\DoxyCodeLine{248   \{\}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250   input.clear();                 \textcolor{comment}{// clear fail and eof bits}}
\DoxyCodeLine{251   input.seekg(0, std::ios::beg); \textcolor{comment}{// back to the start!}}
\DoxyCodeLine{252   }
\DoxyCodeLine{253   \textcolor{keyword}{const} std::string PARSE\_ERROR\_MSG = \textcolor{stringliteral}{"{}Error while parsing map file"{}};}
\DoxyCodeLine{254 }
\DoxyCodeLine{255   \textcolor{keywordflow}{while} (!input.eof())}
\DoxyCodeLine{256   \{}
\DoxyCodeLine{257     \textcolor{keywordtype}{int} size;}
\DoxyCodeLine{258     \textcolor{keywordflow}{if} (!(input >> size))}
\DoxyCodeLine{259     \{}
\DoxyCodeLine{260       \textcolor{keywordflow}{if} (input.eof())}
\DoxyCodeLine{261         \textcolor{keywordflow}{break};}
\DoxyCodeLine{262       std::cerr << PARSE\_ERROR\_MSG << std::endl;}
\DoxyCodeLine{263       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{264     \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266     Obstacle curr;}
\DoxyCodeLine{267     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)}
\DoxyCodeLine{268     \{}
\DoxyCodeLine{269       \textcolor{keywordtype}{double} x, y;}
\DoxyCodeLine{270       \textcolor{keywordflow}{if} (!(input >> x >> y))}
\DoxyCodeLine{271       \{}
\DoxyCodeLine{272         std::cerr << PARSE\_ERROR\_MSG << std::endl;}
\DoxyCodeLine{273         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{274       \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276       curr.push\_back(\{x, y\});}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278 }
\DoxyCodeLine{279     \textcolor{keywordflow}{if} (curr.back()!=curr.front())}
\DoxyCodeLine{280     \{}
\DoxyCodeLine{281       curr.push\_back(curr.front());}
\DoxyCodeLine{282     \}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284     map.push\_back(curr);}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286   }
\DoxyCodeLine{287   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{288 \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{keyword}{inline}}
\DoxyCodeLine{291 std::vector<Obstacle> getObstacles(std::string \textcolor{keyword}{const} \& filename) \{}
\DoxyCodeLine{292   std::vector<Obstacle> res;}
\DoxyCodeLine{293   \textcolor{keywordtype}{bool} ok = getObstacles(filename, res);}
\DoxyCodeLine{294   \textcolor{keywordflow}{if} (!ok) \{}
\DoxyCodeLine{295     res.clear();}
\DoxyCodeLine{296   \}}
\DoxyCodeLine{297   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{298 \}}
\DoxyCodeLine{299 }

\end{DoxyCode}
