\hypertarget{classnlohmann_1_1basic__json_1_1json__pointer}{}\doxysection{nlohmann\+::basic\+\_\+json\texorpdfstring{$<$}{<} Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer \texorpdfstring{$>$}{>}\+::json\+\_\+pointer Class Reference}
\label{classnlohmann_1_1basic__json_1_1json__pointer}\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}


JSON Pointer.  




{\ttfamily \#include $<$json.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}{json\+\_\+pointer}} (const std\+::string \&s=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em create JSON pointer \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_adf63cdde9493796d8aa61bd948984b6d}{to\+\_\+string}} () const noexcept
\begin{DoxyCompactList}\small\item\em return a string representation of the JSON pointer \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_aa2583b66886218c1a035e3e507a5f931}{operator std\+::string}} () const
\begin{DoxyCompactList}\small\item\em return a string representation of the JSON pointer  \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}{json\+\_\+pointer}} (const std\+::string \&s=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em create JSON pointer \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_adf63cdde9493796d8aa61bd948984b6d}{to\+\_\+string}} () const noexcept
\begin{DoxyCompactList}\small\item\em return a string representation of the JSON pointer \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_aa2583b66886218c1a035e3e507a5f931}{operator std\+::string}} () const
\begin{DoxyCompactList}\small\item\em return a string representation of the JSON pointer  \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_ad4ccd113ac7edcdb6c3aaa8f5978db59}\label{classnlohmann_1_1basic__json_1_1json__pointer_ad4ccd113ac7edcdb6c3aaa8f5978db59}} 
std\+::string {\bfseries pop\+\_\+back} ()
\begin{DoxyCompactList}\small\item\em remove and return last reference pointer \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a86445a14d8df77f507bdbd775c8fe281}\label{classnlohmann_1_1basic__json_1_1json__pointer_a86445a14d8df77f507bdbd775c8fe281}} 
bool {\bfseries is\+\_\+root} () const
\begin{DoxyCompactList}\small\item\em return whether pointer points to the root document \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a94a221cb577cba6f4043562c7d3748d9}{get\+\_\+and\+\_\+create}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} j) const
\begin{DoxyCompactList}\small\item\em create and return a reference to the pointed to value \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a3d8f9524a1f16eae37e21a14d7bf214f}{get\+\_\+unchecked}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_aefee1f777198c68724bd127e0c8abbe4}{pointer}} ptr) const
\begin{DoxyCompactList}\small\item\em return a reference to the pointed to value \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_a4057c5425f4faacfe39a8046871786ca}{const\+\_\+reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a90ece68e379ee223cf90d8dc6c875098}{get\+\_\+unchecked}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_aff3d5cd2a75612364b888d8693231b58}{const\+\_\+pointer}} ptr) const
\begin{DoxyCompactList}\small\item\em return a const reference to the pointed to value \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_ad4ccd113ac7edcdb6c3aaa8f5978db59}\label{classnlohmann_1_1basic__json_1_1json__pointer_ad4ccd113ac7edcdb6c3aaa8f5978db59}} 
std\+::string {\bfseries pop\+\_\+back} ()
\begin{DoxyCompactList}\small\item\em remove and return last reference pointer \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a86445a14d8df77f507bdbd775c8fe281}\label{classnlohmann_1_1basic__json_1_1json__pointer_a86445a14d8df77f507bdbd775c8fe281}} 
bool {\bfseries is\+\_\+root} () const
\begin{DoxyCompactList}\small\item\em return whether pointer points to the root document \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a94a221cb577cba6f4043562c7d3748d9}{get\+\_\+and\+\_\+create}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} j) const
\begin{DoxyCompactList}\small\item\em create and return a reference to the pointed to value \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a3d8f9524a1f16eae37e21a14d7bf214f}{get\+\_\+unchecked}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_aefee1f777198c68724bd127e0c8abbe4}{pointer}} ptr) const
\begin{DoxyCompactList}\small\item\em return a reference to the pointed to value \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_a4057c5425f4faacfe39a8046871786ca}{const\+\_\+reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a90ece68e379ee223cf90d8dc6c875098}{get\+\_\+unchecked}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_aff3d5cd2a75612364b888d8693231b58}{const\+\_\+pointer}} ptr) const
\begin{DoxyCompactList}\small\item\em return a const reference to the pointed to value \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_ac0947d2ea20af4facc9beb07a2f30e58}\label{classnlohmann_1_1basic__json_1_1json__pointer_ac0947d2ea20af4facc9beb07a2f30e58}} 
static std\+::vector$<$ std\+::string $>$ {\bfseries split} (const std\+::string \&reference\+\_\+string)
\begin{DoxyCompactList}\small\item\em split the string input to reference tokens \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_afc5dd65e2855e09f46bad1882b2b7ce0}{replace\+\_\+substring}} (std\+::string \&s, const std\+::string \&f, const std\+::string \&t)
\begin{DoxyCompactList}\small\item\em replace all occurrences of a substring by another string \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a7d41132aab61ed2fe8a6b05d53016a70}\label{classnlohmann_1_1basic__json_1_1json__pointer_a7d41132aab61ed2fe8a6b05d53016a70}} 
static std\+::string {\bfseries escape} (std\+::string s)
\begin{DoxyCompactList}\small\item\em escape tilde and slash \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a412a0baf28b38a77cfb44ebb8c8daecc}\label{classnlohmann_1_1basic__json_1_1json__pointer_a412a0baf28b38a77cfb44ebb8c8daecc}} 
static void {\bfseries unescape} (std\+::string \&s)
\begin{DoxyCompactList}\small\item\em unescape tilde and slash \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_adc3a9cbcb4ce12bf4661caf48cd2b30c}{flatten}} (const std\+::string \&reference\+\_\+string, const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&\mbox{\hyperlink{classnlohmann_1_1basic__json_af9c51328fbe1da75eca750be3009917a}{value}}, \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&result)
\item 
static \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a81c5b2e1721430c1bcd2a1fb76a6046e}{unflatten}} (const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&\mbox{\hyperlink{classnlohmann_1_1basic__json_af9c51328fbe1da75eca750be3009917a}{value}})
\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_ac0947d2ea20af4facc9beb07a2f30e58}\label{classnlohmann_1_1basic__json_1_1json__pointer_ac0947d2ea20af4facc9beb07a2f30e58}} 
static std\+::vector$<$ std\+::string $>$ {\bfseries split} (const std\+::string \&reference\+\_\+string)
\begin{DoxyCompactList}\small\item\em split the string input to reference tokens \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_afc5dd65e2855e09f46bad1882b2b7ce0}{replace\+\_\+substring}} (std\+::string \&s, const std\+::string \&f, const std\+::string \&t)
\begin{DoxyCompactList}\small\item\em replace all occurrences of a substring by another string \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a7d41132aab61ed2fe8a6b05d53016a70}\label{classnlohmann_1_1basic__json_1_1json__pointer_a7d41132aab61ed2fe8a6b05d53016a70}} 
static std\+::string {\bfseries escape} (std\+::string s)
\begin{DoxyCompactList}\small\item\em escape tilde and slash \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a412a0baf28b38a77cfb44ebb8c8daecc}\label{classnlohmann_1_1basic__json_1_1json__pointer_a412a0baf28b38a77cfb44ebb8c8daecc}} 
static void {\bfseries unescape} (std\+::string \&s)
\begin{DoxyCompactList}\small\item\em unescape tilde and slash \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_adc3a9cbcb4ce12bf4661caf48cd2b30c}{flatten}} (const std\+::string \&reference\+\_\+string, const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&\mbox{\hyperlink{classnlohmann_1_1basic__json_af9c51328fbe1da75eca750be3009917a}{value}}, \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&result)
\item 
static \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_a81c5b2e1721430c1bcd2a1fb76a6046e}{unflatten}} (const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&\mbox{\hyperlink{classnlohmann_1_1basic__json_af9c51328fbe1da75eca750be3009917a}{value}})
\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a33b7e20712a576833ba36270ac38ebf8}\label{classnlohmann_1_1basic__json_1_1json__pointer_a33b7e20712a576833ba36270ac38ebf8}} 
std\+::vector$<$ std\+::string $>$ {\bfseries reference\+\_\+tokens} \{\}
\begin{DoxyCompactList}\small\item\em the reference tokens \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a069a4f73a702f4c2bc0d14ca1565a7b0}\label{classnlohmann_1_1basic__json_1_1json__pointer_a069a4f73a702f4c2bc0d14ca1565a7b0}} 
class {\bfseries basic\+\_\+json}
\begin{DoxyCompactList}\small\item\em allow \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} to access private members \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type = std\+::string, class Boolean\+Type = bool, class Number\+Integer\+Type = std\+::int64\+\_\+t, class Number\+Unsigned\+Type = std\+::uint64\+\_\+t, class Number\+Float\+Type = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$\newline
class nlohmann\+::basic\+\_\+json$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer}
JSON Pointer. 

A JSON pointer defines a string syntax for identifying a specific value within a JSON document. It can be used with functions {\ttfamily at} and {\ttfamily operator\mbox{[}\mbox{]}}. Furthermore, JSON pointers are the base for JSON patches.

\begin{DoxySeeAlso}{See also}
\href{https://tools.ietf.org/html/rfc6901}{\texttt{ RFC 6901}}
\end{DoxySeeAlso}
\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}\label{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!json\_pointer@{json\_pointer}}
\index{json\_pointer@{json\_pointer}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{json\_pointer()}{json\_pointer()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::json\+\_\+pointer (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



create JSON pointer 

Create a JSON pointer according to the syntax described in \href{https://tools.ietf.org/html/rfc6901\#section-3}{\texttt{ Section 3 of RFC6901}}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em s} & string representing the JSON pointer; if omitted, the empty string is assumed which references the whole JSON value\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::domain\+\_\+error} & if reference token is nonempty and does not begin with a slash ({\ttfamily /}); example\+: {\ttfamily \char`\"{}\+JSON pointer must be empty or begin with /\char`\"{}} \\
\hline
{\em std\+::domain\+\_\+error} & if a tilde ({\ttfamily $\sim$}) is not followed by {\ttfamily 0} (representing {\ttfamily $\sim$}) or {\ttfamily 1} (representing {\ttfamily /}); example\+: {\ttfamily \char`\"{}escape error\+: $\sim$ must be followed with 0 or 1\char`\"{}}\\
\hline
\end{DoxyExceptions}
@liveexample\{The example shows the construction several valid JSON pointers as well as the exceptional behavior.,\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer}{json\+\_\+pointer}}\}

\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}\label{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!json\_pointer@{json\_pointer}}
\index{json\_pointer@{json\_pointer}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{json\_pointer()}{json\_pointer()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::json\+\_\+pointer (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



create JSON pointer 

Create a JSON pointer according to the syntax described in \href{https://tools.ietf.org/html/rfc6901\#section-3}{\texttt{ Section 3 of RFC6901}}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em s} & string representing the JSON pointer; if omitted, the empty string is assumed which references the whole JSON value\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::domain\+\_\+error} & if reference token is nonempty and does not begin with a slash ({\ttfamily /}); example\+: {\ttfamily \char`\"{}\+JSON pointer must be empty or begin with /\char`\"{}} \\
\hline
{\em std\+::domain\+\_\+error} & if a tilde ({\ttfamily $\sim$}) is not followed by {\ttfamily 0} (representing {\ttfamily $\sim$}) or {\ttfamily 1} (representing {\ttfamily /}); example\+: {\ttfamily \char`\"{}escape error\+: $\sim$ must be followed with 0 or 1\char`\"{}}\\
\hline
\end{DoxyExceptions}
@liveexample\{The example shows the construction several valid JSON pointers as well as the exceptional behavior.,\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer}{json\+\_\+pointer}}\}

\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_adc3a9cbcb4ce12bf4661caf48cd2b30c}\label{classnlohmann_1_1basic__json_1_1json__pointer_adc3a9cbcb4ce12bf4661caf48cd2b30c}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!flatten@{flatten}}
\index{flatten@{flatten}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{flatten()}{flatten()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
static void \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::flatten (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{reference\+\_\+string,  }\item[{const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&}]{value,  }\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reference\+\_\+string} & the reference string to the current value \\
\hline
\mbox{\texttt{ in}}  & {\em value} & the value to consider \\
\hline
\mbox{\texttt{ in,out}}  & {\em result} & the result object to insert values to\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Empty objects or arrays are flattened to {\ttfamily null}. 
\end{DoxyNote}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_adc3a9cbcb4ce12bf4661caf48cd2b30c}\label{classnlohmann_1_1basic__json_1_1json__pointer_adc3a9cbcb4ce12bf4661caf48cd2b30c}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!flatten@{flatten}}
\index{flatten@{flatten}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{flatten()}{flatten()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
static void \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::flatten (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{reference\+\_\+string,  }\item[{const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&}]{value,  }\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reference\+\_\+string} & the reference string to the current value \\
\hline
\mbox{\texttt{ in}}  & {\em value} & the value to consider \\
\hline
\mbox{\texttt{ in,out}}  & {\em result} & the result object to insert values to\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Empty objects or arrays are flattened to {\ttfamily null}. 
\end{DoxyNote}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a94a221cb577cba6f4043562c7d3748d9}\label{classnlohmann_1_1basic__json_1_1json__pointer_a94a221cb577cba6f4043562c7d3748d9}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!get\_and\_create@{get\_and\_create}}
\index{get\_and\_create@{get\_and\_create}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{get\_and\_create()}{get\_and\_create()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::get\+\_\+and\+\_\+create (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}}}]{j }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



create and return a reference to the pointed to value 

@complexity Linear in the number of reference tokens. \mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a94a221cb577cba6f4043562c7d3748d9}\label{classnlohmann_1_1basic__json_1_1json__pointer_a94a221cb577cba6f4043562c7d3748d9}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!get\_and\_create@{get\_and\_create}}
\index{get\_and\_create@{get\_and\_create}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{get\_and\_create()}{get\_and\_create()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::get\+\_\+and\+\_\+create (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}}}]{j }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



create and return a reference to the pointed to value 

@complexity Linear in the number of reference tokens. \mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a90ece68e379ee223cf90d8dc6c875098}\label{classnlohmann_1_1basic__json_1_1json__pointer_a90ece68e379ee223cf90d8dc6c875098}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!get\_unchecked@{get\_unchecked}}
\index{get\_unchecked@{get\_unchecked}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{get\_unchecked()}{get\_unchecked()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json_a4057c5425f4faacfe39a8046871786ca}{const\+\_\+reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::get\+\_\+unchecked (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_aff3d5cd2a75612364b888d8693231b58}{const\+\_\+pointer}}}]{ptr }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



return a const reference to the pointed to value 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ptr} & a JSON value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
const reference to the JSON value pointed to by the JSON pointer 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a90ece68e379ee223cf90d8dc6c875098}\label{classnlohmann_1_1basic__json_1_1json__pointer_a90ece68e379ee223cf90d8dc6c875098}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!get\_unchecked@{get\_unchecked}}
\index{get\_unchecked@{get\_unchecked}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{get\_unchecked()}{get\_unchecked()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json_a4057c5425f4faacfe39a8046871786ca}{const\+\_\+reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::get\+\_\+unchecked (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_aff3d5cd2a75612364b888d8693231b58}{const\+\_\+pointer}}}]{ptr }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



return a const reference to the pointed to value 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ptr} & a JSON value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
const reference to the JSON value pointed to by the JSON pointer 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a3d8f9524a1f16eae37e21a14d7bf214f}\label{classnlohmann_1_1basic__json_1_1json__pointer_a3d8f9524a1f16eae37e21a14d7bf214f}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!get\_unchecked@{get\_unchecked}}
\index{get\_unchecked@{get\_unchecked}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{get\_unchecked()}{get\_unchecked()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::get\+\_\+unchecked (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_aefee1f777198c68724bd127e0c8abbe4}{pointer}}}]{ptr }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



return a reference to the pointed to value 

\begin{DoxyNote}{Note}
This version does not throw if a value is not present, but tries to create nested values instead. For instance, calling this function with pointer {\ttfamily \char`\"{}/this/that\char`\"{}} on a null value is equivalent to calling {\ttfamily operator\mbox{[}\mbox{]}(\char`\"{}this\char`\"{}).operator\mbox{[}\mbox{]}(\char`\"{}that\char`\"{})} on that value, effectively changing the null value to an object.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ptr} & a JSON value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to the JSON value pointed to by the JSON pointer
\end{DoxyReturn}
@complexity Linear in the length of the JSON pointer.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if the JSON pointer can not be resolved \\
\hline
{\em std\+::domain\+\_\+error} & if an array index begins with \textquotesingle{}0\textquotesingle{} \\
\hline
{\em std\+::invalid\+\_\+argument} & if an array index was not a number \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a3d8f9524a1f16eae37e21a14d7bf214f}\label{classnlohmann_1_1basic__json_1_1json__pointer_a3d8f9524a1f16eae37e21a14d7bf214f}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!get\_unchecked@{get\_unchecked}}
\index{get\_unchecked@{get\_unchecked}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{get\_unchecked()}{get\_unchecked()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json_ac6a5eddd156c776ac75ff54cfe54a5bc}{reference}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::get\+\_\+unchecked (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_aefee1f777198c68724bd127e0c8abbe4}{pointer}}}]{ptr }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



return a reference to the pointed to value 

\begin{DoxyNote}{Note}
This version does not throw if a value is not present, but tries to create nested values instead. For instance, calling this function with pointer {\ttfamily \char`\"{}/this/that\char`\"{}} on a null value is equivalent to calling {\ttfamily operator\mbox{[}\mbox{]}(\char`\"{}this\char`\"{}).operator\mbox{[}\mbox{]}(\char`\"{}that\char`\"{})} on that value, effectively changing the null value to an object.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ptr} & a JSON value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
reference to the JSON value pointed to by the JSON pointer
\end{DoxyReturn}
@complexity Linear in the length of the JSON pointer.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & if the JSON pointer can not be resolved \\
\hline
{\em std\+::domain\+\_\+error} & if an array index begins with \textquotesingle{}0\textquotesingle{} \\
\hline
{\em std\+::invalid\+\_\+argument} & if an array index was not a number \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_aa2583b66886218c1a035e3e507a5f931}\label{classnlohmann_1_1basic__json_1_1json__pointer_aa2583b66886218c1a035e3e507a5f931}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!operator std::string@{operator std::string}}
\index{operator std::string@{operator std::string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{operator std::string()}{operator std::string()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::operator std\+::string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



return a string representation of the JSON pointer  

\begin{DoxyInvariant}{Invariant}
For each JSON pointer {\ttfamily ptr}, it holds\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ptr == \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}{json\_pointer}}(ptr.to\_string());}

\end{DoxyCode}

\end{DoxyInvariant}
\begin{DoxyReturn}{Returns}
a string representation of the JSON pointer
\end{DoxyReturn}
@liveexample\{The example shows the result of {\ttfamily to\+\_\+string}., json\+\_\+pointer\+\_\+\+\_\+to\+\_\+string\}

\begin{DoxySince}{Since}
version 2.\+0.\+0  
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_aa2583b66886218c1a035e3e507a5f931}\label{classnlohmann_1_1basic__json_1_1json__pointer_aa2583b66886218c1a035e3e507a5f931}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!operator std::string@{operator std::string}}
\index{operator std::string@{operator std::string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{operator std::string()}{operator std::string()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::operator std\+::string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



return a string representation of the JSON pointer  

\begin{DoxyInvariant}{Invariant}
For each JSON pointer {\ttfamily ptr}, it holds\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ptr == \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}{json\_pointer}}(ptr.to\_string());}

\end{DoxyCode}

\end{DoxyInvariant}
\begin{DoxyReturn}{Returns}
a string representation of the JSON pointer
\end{DoxyReturn}
@liveexample\{The example shows the result of {\ttfamily to\+\_\+string}., json\+\_\+pointer\+\_\+\+\_\+to\+\_\+string\}

\begin{DoxySince}{Since}
version 2.\+0.\+0  
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_afc5dd65e2855e09f46bad1882b2b7ce0}\label{classnlohmann_1_1basic__json_1_1json__pointer_afc5dd65e2855e09f46bad1882b2b7ce0}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!replace\_substring@{replace\_substring}}
\index{replace\_substring@{replace\_substring}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{replace\_substring()}{replace\_substring()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
static void \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::replace\+\_\+substring (\begin{DoxyParamCaption}\item[{std\+::string \&}]{s,  }\item[{const std\+::string \&}]{f,  }\item[{const std\+::string \&}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}



replace all occurrences of a substring by another string 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em s} & the string to manipulate; changed so that all occurrences of {\itshape f} are replaced with {\itshape t} \\
\hline
\mbox{\texttt{ in}}  & {\em f} & the substring to replace with {\itshape t} \\
\hline
\mbox{\texttt{ in}}  & {\em t} & the string to replace {\itshape f} \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The search string {\itshape f} must not be empty.
\end{DoxyPrecond}
\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_afc5dd65e2855e09f46bad1882b2b7ce0}\label{classnlohmann_1_1basic__json_1_1json__pointer_afc5dd65e2855e09f46bad1882b2b7ce0}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!replace\_substring@{replace\_substring}}
\index{replace\_substring@{replace\_substring}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{replace\_substring()}{replace\_substring()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
static void \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::replace\+\_\+substring (\begin{DoxyParamCaption}\item[{std\+::string \&}]{s,  }\item[{const std\+::string \&}]{f,  }\item[{const std\+::string \&}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}



replace all occurrences of a substring by another string 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em s} & the string to manipulate; changed so that all occurrences of {\itshape f} are replaced with {\itshape t} \\
\hline
\mbox{\texttt{ in}}  & {\em f} & the substring to replace with {\itshape t} \\
\hline
\mbox{\texttt{ in}}  & {\em t} & the string to replace {\itshape f} \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The search string {\itshape f} must not be empty.
\end{DoxyPrecond}
\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_adf63cdde9493796d8aa61bd948984b6d}\label{classnlohmann_1_1basic__json_1_1json__pointer_adf63cdde9493796d8aa61bd948984b6d}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!to\_string@{to\_string}}
\index{to\_string@{to\_string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{to\_string()}{to\_string()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::to\+\_\+string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



return a string representation of the JSON pointer 

\begin{DoxyInvariant}{Invariant}
For each JSON pointer {\ttfamily ptr}, it holds\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ptr == \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}{json\_pointer}}(ptr.to\_string());}

\end{DoxyCode}

\end{DoxyInvariant}
\begin{DoxyReturn}{Returns}
a string representation of the JSON pointer
\end{DoxyReturn}
@liveexample\{The example shows the result of {\ttfamily to\+\_\+string}., json\+\_\+pointer\+\_\+\+\_\+to\+\_\+string\}

\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_adf63cdde9493796d8aa61bd948984b6d}\label{classnlohmann_1_1basic__json_1_1json__pointer_adf63cdde9493796d8aa61bd948984b6d}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!to\_string@{to\_string}}
\index{to\_string@{to\_string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{to\_string()}{to\_string()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::to\+\_\+string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



return a string representation of the JSON pointer 

\begin{DoxyInvariant}{Invariant}
For each JSON pointer {\ttfamily ptr}, it holds\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ptr == \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1json__pointer_abaa66b0d30811b8a8670a673c686b75a}{json\_pointer}}(ptr.to\_string());}

\end{DoxyCode}

\end{DoxyInvariant}
\begin{DoxyReturn}{Returns}
a string representation of the JSON pointer
\end{DoxyReturn}
@liveexample\{The example shows the result of {\ttfamily to\+\_\+string}., json\+\_\+pointer\+\_\+\+\_\+to\+\_\+string\}

\begin{DoxySince}{Since}
version 2.\+0.\+0 
\end{DoxySince}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a81c5b2e1721430c1bcd2a1fb76a6046e}\label{classnlohmann_1_1basic__json_1_1json__pointer_a81c5b2e1721430c1bcd2a1fb76a6046e}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!unflatten@{unflatten}}
\index{unflatten@{unflatten}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{unflatten()}{unflatten()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
static \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::unflatten (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em value} & flattened JSON\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
unflattened JSON 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1json__pointer_a81c5b2e1721430c1bcd2a1fb76a6046e}\label{classnlohmann_1_1basic__json_1_1json__pointer_a81c5b2e1721430c1bcd2a1fb76a6046e}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}!unflatten@{unflatten}}
\index{unflatten@{unflatten}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::json\_pointer}}
\doxysubsubsection{\texorpdfstring{unflatten()}{unflatten()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename SFINAE=void $>$ class JSONSerializer = adl\+\_\+serializer$>$ \\
static \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, JSONSerializer $>$\+::json\+\_\+pointer\+::unflatten (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em value} & flattened JSON\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
unflattened JSON 
\end{DoxyReturn}
