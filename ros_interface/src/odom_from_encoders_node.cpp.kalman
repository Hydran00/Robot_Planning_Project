#include <iostream>
#include <iomanip>
#include <atomic>
#include <future>
#include <thread>
#include <signal.h>
#include <cmath>

#include "ros/ros.h"
#include "nav_msgs/Odometry.h"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/PoseWithCovarianceStamped.h"
#include "geometry_msgs/Twist.h"
#include "sensor_msgs/LaserScan.h"
#include <tf/transform_broadcaster.h>
#include <ros/callback_queue.h>

#include "ros_interface/Encoders.h"

#include "FusionEKF.h"
#include "LocalizationStreamerDefinitions.hpp"

using namespace std;


// static const double LEFT_INCREMENTS_PER_TOUR = 294912.;
// static const double RIGHT_INCREMENTS_PER_TOUR = 294570.;
// static const double LEFT_B_D = 1.5764889187282987 * 1.0625; // * 1.0697 ; // * 1.08203;
// static const double RIGHT_B_D = 1.5784089237419516 * 1.0625; // * 1.0697 ; // * 1.08203;


// static const double RATIO_LEFT_RIGHT = RIGHT_B_D/LEFT_B_D;
// static const double RADIUS_SCALING = 0.476; //0.45971498589878657;
// static const double LEFT_RADIUS = RADIUS_SCALING;
// static const double RIGHT_RADIUS = LEFT_RADIUS/RATIO_LEFT_RIGHT;


struct OdomData {
  double x, y, theta;
  double v, omega;
  std::vector<double> cov;
  double last_odom_update;
  std::mutex mtx;

  OdomData():
    x(0.0), y(0.0), theta(0), v(0), omega(0), last_odom_update(0)
    //x(340), y(-16.5), theta(M_PI), v(0), omega(0), last_odom_update(0)
  {}
} odomData;

// struct WheelSpeed {
//   double dTick;
//   //double lastTick;
//   double lastTime;
//   bool init = false;
// };

// WheelSpeed wsLeft, wsRight;


FusionEKF kf;

void runNode(int argc, char* argv[]);
//void updateOdometry(OdomData & odomData, double data_time, WheelSpeed const & vl, WheelSpeed const & vr);
void publishOdometry(ros::Publisher & publisher, tf::TransformBroadcaster & transform_broadcaster, const ros::Time & current_time, OdomData & odomData);


int main(int argc, char* argv[]) {
  runNode(argc, argv);
  return 0;
}




void runNode(int argc, char* argv[]) {
  ros::init(argc, argv, "odom_interface");

  ros::NodeHandlePtr nh_priv = boost::make_shared<ros::NodeHandle>("~");
  ros::NodeHandlePtr nh = boost::make_shared<ros::NodeHandle>();

  // configuring parameters
  std::string encoders_topic, odom_topic, odomPublisher;
  nh_priv->param<std::string>("encoders_topic", encoders_topic, "/encoders");
  nh_priv->param<std::string>("odom_topic", odom_topic, "/odom");

  tf::TransformBroadcaster transform_broadcaster;
  ros::Publisher publisher = nh->advertise<nav_msgs::Odometry>(odom_topic, 0);

  double dt = 0;
  boost::function<void(const ros_interface::Encoders::ConstPtr&)> cb = [&](const ros_interface::Encoders::ConstPtr& msg) {
    double vl = msg->leftVel;
    double vr = msg->rightVel;
    // vr = -vr;

    MeasurementPackage measurement_pack;
    measurement_pack.sensor_type_ = MeasurementPackage::ENCODER;
    measurement_pack.timestamp_   = msg->time * 1000; 

    measurement_pack.raw_measurements_    = Eigen::VectorXd(2);
    measurement_pack.raw_measurements_(0) = vl;
    measurement_pack.raw_measurements_(1) = vr;

    kf.ProcessMeasurement(measurement_pack);

    // double current_time = msg->time; 

    // if (!wsLeft.init) {
    //   wsLeft.dTick = 0;
    //   //wsLeft.lastTick = pL;
    //   wsLeft.lastTime = current_time;
    //   wsLeft.init = true;
    // }
    // else {
    //   wsLeft.dTick = (vl*36/(2*M_PI)*2048)*(current_time-wsLeft.lastTime); //pL-wsLeft.lastTick;
    //   //wsLeft.lastTick = pL;
    //   wsLeft.lastTime = current_time;
    // }

    // if (!wsRight.init) {
    //   wsRight.dTick = 0;
    //   //wsRight.lastTick = pR;
    //   wsRight.lastTime = current_time;
    //   wsRight.init = true;
    // }
    // else {
    //   wsRight.dTick = (vr*36/(2*M_PI)*2048)*(current_time-wsRight.lastTime); //pR-wsRight.lastTick;
    //   //wsRight.lastTick = pR;
    //   wsRight.lastTime = current_time;
    // }

    // updateOdometry(odomData, current_time, wsLeft, wsRight);

    Localization::data_t streamer_data;
    int timeMs;
    kf.getLastFilterInformation(timeMs, streamer_data.state, streamer_data.covariance);

    odomData.last_odom_update = timeMs/1000.;
    odomData.x = streamer_data.x;
    odomData.y = streamer_data.y;
    odomData.theta = streamer_data.theta;
    odomData.v = streamer_data.v;
    odomData.omega = streamer_data.omega;

    odomData.cov.clear();
    odomData.cov.reserve(streamer_data.covariance.size());
    for (int i=0; i<streamer_data.covariance.rows(); ++i) {
      for (int j=0; j<streamer_data.covariance.cols(); ++j) {
        odomData.cov.push_back(streamer_data.covariance(i,j));
      } 
    }
    publishOdometry(publisher, transform_broadcaster, msg->stamp, odomData);
  };

  // define user callback queue
  ros::CallbackQueue encoders_queue;
  
  // create options for subscriber and pass pointer to our custom queue
  ros::SubscribeOptions ops =
    ros::SubscribeOptions::create<ros_interface::Encoders>(
      encoders_topic, // topic name
      1, // queue length
      cb, // callback
      nullptr,
      &encoders_queue // pointer to callback queue object
    );
  // subscribe
  ros::Subscriber encoders_sub = nh->subscribe(ops);
  
  while (ros::ok())
  {
    encoders_queue.callAvailable(ros::WallDuration(0.1));
  }
}

// void updateOdometry(OdomData & odomData, double current_time, WheelSpeed const & wl, WheelSpeed const & wr) {
//   std::unique_lock<std::mutex> lock(odomData.mtx);
//   double seconds_since_last_update = current_time - odomData.last_odom_update;
//   if (seconds_since_last_update == 0.) {
//     return;
//   }

//   odomData.last_odom_update = current_time;

//   double ticks_l = wl.dTick;
//   double ticks_r = wr.dTick;

//   //std::cerr << ticks_l << " " << (ticks_l/LEFT_INCREMENTS_PER_TOUR)/seconds_since_last_update << std::endl;
  
//   double df = 0.5 * (ticks_l/LEFT_INCREMENTS_PER_TOUR * 2*M_PI * LEFT_RADIUS + ticks_r/RIGHT_INCREMENTS_PER_TOUR * 2*M_PI * RIGHT_RADIUS);
//   double dtheta = (ticks_r/RIGHT_INCREMENTS_PER_TOUR * 2*M_PI * 2./RIGHT_B_D - ticks_l/LEFT_INCREMENTS_PER_TOUR * 2*M_PI * 2./LEFT_B_D);

//   double dx = df * std::cos ( odomData.theta + 0.5*dtheta );
//   double dy = df * std::sin ( odomData.theta + 0.5*dtheta );

//   odomData.x += dx;
//   odomData.y += dy;
//   odomData.theta += dtheta;
//   odomData.omega = dtheta/seconds_since_last_update;
//   odomData.v = sqrt ( dx*dx+dy*dy ) /seconds_since_last_update;
// }

void publishOdometry(ros::Publisher & publisher,  tf::TransformBroadcaster & transform_broadcaster, const ros::Time & current_time, OdomData & odomData) {
  static int64_t id = 1;

  std::string odom_frame = "odom";
  std::string base_link_frame = "base_link";


  double x = odomData.x;
  double y = odomData.y;
  double theta = odomData.theta;
  double v = odomData.v;
  double omega = odomData.omega;
  std::vector<double> cov = odomData.cov; // std::vector<double>(25, 0.01); // j.at("covariance");

  tf::Quaternion qt;
  tf::Vector3 vt;
  qt.setRPY(0., 0., theta);
  vt = tf::Vector3(x, y, 0.);

  nav_msgs::Odometry msg;
  msg.header.seq = id++;
  msg.header.stamp = current_time;
  msg.header.frame_id = odom_frame;
  
  msg.child_frame_id = base_link_frame;

  msg.pose.pose.position.x = vt.x();
  msg.pose.pose.position.y = vt.y();
  msg.pose.pose.position.z = vt.z();

  msg.pose.pose.orientation.x = qt.x();
  msg.pose.pose.orientation.y = qt.y();
  msg.pose.pose.orientation.z = qt.z();
  msg.pose.pose.orientation.w = qt.w();

  msg.pose.covariance[0] = cov[0]; // cov_x
  msg.pose.covariance[7] = cov[6]; // cov_y
  msg.pose.covariance[14] = 1000000000000.0;
  msg.pose.covariance[21] = 1000000000000.0;
  msg.pose.covariance[28] = 1000000000000.0;
  msg.pose.covariance[35] = cov[12]; // cov_theta
  
  msg.twist.twist.linear.x = v;
  msg.twist.twist.angular.z = omega;
  msg.twist.covariance[0] = cov[18]; // cov_v_x
  msg.twist.covariance[7] = cov[18]; // cov_v_y
  msg.twist.covariance[14] = 1000000000000.0;
  msg.twist.covariance[21] = 1000000000000.0;
  msg.twist.covariance[28] = 1000000000000.0;
  msg.twist.covariance[35] = cov[24]; // cov_omega

  tf::Transform base_link_to_odom(qt, vt);
  transform_broadcaster.sendTransform(tf::StampedTransform(base_link_to_odom, current_time,
    odom_frame, base_link_frame));

  publisher.publish(msg);
}

